use crate::buildable::Buildable;
use crate::builder::builder::*;
use crate::builder::helper::separate_docs::separate_docs;
use crate::builder::prism_node::node::{arguments_node, block_argument_node};
use crate::document::Document;
use crate::helper::build_receiver::build_receiver;
use crate::{BuildPrismNode, BuildPrismNodeList};
use ruby_prism::CallNode;


const OPEN_PAREN: &str = "(";
const CLOSE_PAREN: &str = ")";
const ARGUMENTS_SEPARATOR: &str = ",";
const DOT_OPERATOR: &str = ".";
const SAFE_NAVIGATION_OPERATOR: &str = "&.";
const OPERATOR_METHODS: &[&str] = &[
    "|",   // ...
    "^",   // ...
    "&",   // ...
    "<=>", // ...
    "==",  // ...
    "===", // ...
    "=~",  // ...
    ">",   // ...
    ">=",  // ...
    "<",   // ...
    "<=",  // ...
    "<<",  // ...
    ">>",  // ...
    "+",   // ...
    "-",   // ...
    "*",   // ...
    "/",   // ...
    "%",   // ...
    "**",  // ...
    "~",   // ...
    "+@",  // ...
    "-@",  // ...
    "[]",  // ...
    "[]=", // ...
    "`",   // ...
    "!",   // ...
    "!=",  // ...
    "!~",  // ...
];
const SELF_ASSIGNABLE_METHODS: &[&str] = &[
    "+",  // ...
    "-",  // ...
    "*",  // ...
    "/",  // ...
    "%",  // ...
    "**", // ...
    "&",  // ...
    "|",  // ...
    "^",  // ...
    "<<", // ...
    ">>", // ...
    "&&", // ...
    "||", // ...
];
use crate::BuildContext;


pub fn build_node(node: Option<&CallNode>, context: &mut BuildContext) -> Document {
    let node = node.unwrap();

    let doc_name = build_name(context, node);
    let doc_arguments = build_arguments(context, node);
    let doc_block = build_block(context, node);

    // 変数呼び出しの場合
    if node.is_variable_call() {
        return doc_name;
    }

    group(array(&[doc_name, doc_arguments, doc_block]))
}

fn build_name(context: &mut BuildContext, node: &CallNode) -> Document {
    // TODO: オペレータ個別の処理を追加
    let is_safe_navigation = node.is_safe_navigation();
    let receiver = node.receiver();
    let name = node.name();
    match receiver {
        Some(_) => array(&[
            build_receiver(receiver.as_ref(), is_safe_navigation, context),
            name.build(context),
        ]),
        None => name.build(context),
    }
}

fn build_arguments(context: &mut BuildContext, node: &CallNode) -> Document {
    let arguments = node.arguments();
    let block = node.block();
    let block_argument = block.and_then(|node| node.as_block_argument_node());
    let doc_arguments = arguments.build(context);
    let doc_block_argument = block_argument.build(context);
    match (arguments, block_argument) {
        (None, None) => none(),
        _ => group(array(&[
            string(OPEN_PAREN),
            indent(array(&[
                softline(),
                array(&separate_docs(
                    &[doc_arguments, doc_block_argument],
                    array(&[string(ARGUMENTS_SEPARATOR), line()]),
                )),
            ])),
            softline(),
            string(CLOSE_PAREN),
        ])),
    }
}

fn build_block(context: &mut BuildContext, node: &CallNode) -> Document {
    let block = node.block();
    block.build(context)
}
