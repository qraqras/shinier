use crate::builder::Buildable;
use crate::builder::layout::{separate, separate_docs};
use crate::builder::prism_node::node::{arguments_node, block_argument_node};
use crate::doc::{self, Doc, group, indent, line, none, sequence, softline, space, text};
use crate::helper::receiver::build_receiver;
use crate::text_constant;
use ruby_prism::{CallNode, Node};

const OPEN_PAREN: &str = "(";
const CLOSE_PAREN: &str = ")";
const ARGUMENTS_SEPARATOR: &str = ",";
const DOT_OPERATOR: &str = ".";
const SAFE_NAVIGATION_OPERATOR: &str = "&.";
const OPERATOR_METHODS: &[&str] = &[
    "|",   // ...
    "^",   // ...
    "&",   // ...
    "<=>", // ...
    "==",  // ...
    "===", // ...
    "=~",  // ...
    ">",   // ...
    ">=",  // ...
    "<",   // ...
    "<=",  // ...
    "<<",  // ...
    ">>",  // ...
    "+",   // ...
    "-",   // ...
    "*",   // ...
    "/",   // ...
    "%",   // ...
    "**",  // ...
    "~",   // ...
    "+@",  // ...
    "-@",  // ...
    "[]",  // ...
    "[]=", // ...
    "`",   // ...
    "!",   // ...
    "!=",  // ...
    "!~",  // ...
];
const SELF_ASSIGNABLE_METHODS: &[&str] = &[
    "+",  // ...
    "-",  // ...
    "*",  // ...
    "/",  // ...
    "%",  // ...
    "**", // ...
    "&",  // ...
    "|",  // ...
    "^",  // ...
    "<<", // ...
    ">>", // ...
    "&&", // ...
    "||", // ...
];

pub fn build_node(node: Option<&CallNode>) -> Doc {
    let node = node.unwrap();

    let doc_name = build_name(node);
    let doc_arguments = build_arguments(node);
    let doc_block = build_block(node);

    // 変数呼び出しの場合
    if node.is_variable_call() {
        return doc_name;
    }

    group(&[doc_name, doc_arguments, doc_block])
}

fn build_name(node: &CallNode) -> Doc {
    // TODO: オペレータ個別の処理を追加
    let is_safe_navigation = node.is_safe_navigation();
    let receiver = node.receiver();
    let name = node.name();
    sequence(&[
        build_receiver(receiver.as_ref(), is_safe_navigation),
        text_constant(&name),
    ])
}

fn build_arguments(node: &CallNode) -> Doc {
    let arguments = node.arguments();
    let block = node.block();
    let block_argument = block.and_then(|node| node.as_block_argument_node());
    let doc_arguments = arguments_node::build_node(arguments.as_ref());
    let doc_block_argument = block_argument_node::build_node(block_argument.as_ref());
    match (arguments, block_argument) {
        (None, None) => none(),
        _ => group(&[
            text(OPEN_PAREN),
            softline(),
            indent(&separate_docs(
                &[doc_arguments, doc_block_argument],
                &sequence(&[text(ARGUMENTS_SEPARATOR), line()]),
            )),
            softline(),
            text(CLOSE_PAREN),
        ]),
    }
}

fn build_block(node: &CallNode) -> Doc {
    let block = node.block();
    block.build()
}
